--[[
lua test script (I tested on http://www.lua.org/cgi-bin/demo for simplicity)

results
    counter = 0
        failure rate: 0.398
    counter = 100
        failure rate: 0.3972
    counter = 1,000
        failure rate: 0.382
    counter = 10,000
        failure rate: 0.2682
    counter = 100,000
        failure rate: 0.1578
--]]


-- test code below
function DynamicFailure(counter)
    local basePercent = 400 -- the percent chance (times 10) of returning true when counter is 0.
    local minModifier = 250 -- basePercent-minModifier equals the percentage chance as normalized counter approaches minModifier.
    local modifier = 250000000 -- decrease to lower value of counter needed to approach minModifier
    
    -- normalize counter to ~(0,minModifier). with a minModifier of 250, counter normalizes as: 10,000 to 133.6, 100,000 to 246.9
    -- equation taken from http://people.revoledu.com/kardi/tutorial/Similarity/Normalization.html
    local normalCounter = minModifier*((counter/math.pow((math.pow(counter,2)+modifier), 0.5)))
    
    --now:
    -- return true basePercent% when normalCounter=0, as normalCounter approaches minModifier returns true (basePercent-minModifier)%
    -- ie: with a basePercent of 400 and a minModifier of 250, returns true 40% at 0 and 15% at minModifier.
    -- The +1 is here so there are basePercent numbers smaller than the basePercent when choosing a random number between 1 and 100.
    if math.random(1000)<(basePercent+1-normalCounter) then
        return true
    else
        return false
    end
end

counts = {}
counts["true"]=0
counts["false"]=0

for i=1, 5000 do
  if DynamicFailure(100000000) then
    counts["true"]=counts["true"]+1
  else
    counts["false"]=counts["false"]+1
  end
end

print("true results: "..counts["true"])
print("false results: "..counts["false"])
print("Percent true, aka failure rate: "..counts["true"]/(counts["true"]+counts["false"]))